package validator

import (
	"errors"
	"fmt"
	"reflect"
	"regexp"
	"strings"

	validate "github.com/go-playground/validator/v10"
	"github.com/pelletier/go-toml/v2"
)

/*
codeframeFieldRegexp is a regular expression used for matching a TOML field present in the codeframe generated by go-toml's StrictMissingError.
Ref: The example here: https://pkg.go.dev/github.com/pelletier/go-toml/v2#example-Decoder.DisallowUnknownFields
The output looks like this:
strict mode: fields in the document are missing in the target struct
2| key1 = "value1"
3| key2 = "value2"
 | ~~~~ missing field
4| key3 = "value3"
*/
var codeframeFieldRegexp = `\d\s*[|]\s*(?P<field>\w+)\s*=\s*\S*`

// Returns the list of required fields from the error message returned by the `go-playground/validator` library
func getMissingRequiredFields(err error, config interface{}) []string {
	missingRequiredFields := []string{}
	errs := err.(validate.ValidationErrors)
	for _, err := range errs {
		if err.Tag() == "required" {
			c := reflect.ValueOf(config)
			for i := 0; i < c.Type().NumField(); i++ {
				if err.Field() == c.Type().Field(i).Name {
					missingRequiredFields = append(missingRequiredFields, c.Type().Field(i).Tag.Get("toml"))
				}
			}
		}
	}
	return missingRequiredFields
}

// Handle decoding errors reported by go-toml
func handleTOMLDecodeErrors(err error, filePath string) *ValidationFailure {
	// We check for go-toml's StrictMissingError, as the decoder returns a StrictMissingError when there exists a mismatch between the destination and the extracted fields.
	// go-toml doesn't return the field name associated with the error, however, StrictMissingError returns a human-readable codeframe, which can be used to extract the error-causing fields.
	// Ref: https://pkg.go.dev/github.com/pelletier/go-toml/v2#example-Decoder.DisallowUnknownFields

	var strictMissingError *toml.StrictMissingError
	if errors.As(err, &strictMissingError) {
		validationError := handleStrictMissingError(strictMissingError, filePath)

		return &validationError
	}

	// Check if the error is of the type "DecodeError" exported by go-toml.
	// Ref: https://pkg.go.dev/github.com/pelletier/go-toml/v2#DecodeError
	var decodeErr *toml.DecodeError
	if !errors.As(err, &decodeErr) {
		validationError := ValidationFailure{
			File: filePath,
			Errors: []ErrorMeta{
				{
					Level:   DecodeErr,
					Field:   "",
					Message: err.Error(),
				},
			},
		}
		return &validationError
	}

	// Handle DecodeErr.
	errorMessage := decodeErr.Error()
	validationError := handleDecodeErr(errorMessage, filePath)
	return &validationError
}

// handleDecodeErr extracts the required data from the decoding errors of the TOML of type other than DecodeError and StrictMissingError and returns a validation failure response.
func handleDecodeErr(errorMessage, filePath string) ValidationFailure {
	var usefulResponse, expectedType, receivedType, fieldName, decodeErrorMessage string

	// Error case 1: `toml: cannot decode TOML integer into struct field types.AnalyzerTOML.Name of type string"`
	if strings.HasPrefix(errorMessage, "toml: cannot decode TOML") {

		usefulResponse = strings.TrimPrefix(errorMessage, "toml: cannot decode TOML ")
		responseArray := strings.Split(usefulResponse, " ")

		expectedType = responseArray[len(responseArray)-1]
		receivedType = responseArray[0]
		fieldData := responseArray[len(responseArray)-4]
		index := strings.LastIndex(fieldData, ".")
		fieldName = strings.ToLower(fieldData[index:])
		// Framing the decoding failure error message
		decodeErrorMessage = fmt.Sprintf("expected the field \"%s\" of type %s. Got %s.", fieldName, expectedType, receivedType)

	} else if strings.HasPrefix(errorMessage, "toml: cannot store TOML") {

		// Error case 2: `toml: cannot store TOML string into a Go slice`
		usefulResponse = strings.TrimPrefix(errorMessage, "toml: cannot store TOML ")
		responseArray := strings.Split(usefulResponse, " ")

		expectedType = responseArray[len(responseArray)-1]
		receivedType = responseArray[0]
		decodeErrorMessage = fmt.Sprintf("expected type for one of the fields : %s. Received: %s.", expectedType, receivedType)
	} else {
		decodeErrorMessage = errorMessage
		fieldName = ""
	}

	validationError := ValidationFailure{
		File: filePath,
		Errors: []ErrorMeta{
			{
				Level:   DecodeErr,
				Field:   fieldName,
				Message: decodeErrorMessage,
			},
		},
	}

	return validationError
}

// handleStrictMissingError handles StrictMissingError reported by go-toml, and returns a validation failure response.
func handleStrictMissingError(strictMissingError *toml.StrictMissingError, filePath string) ValidationFailure {
	// Extract human-readable codeframe.
	codeframe := strictMissingError.String()

	// Retrieve field names from the codeframe.
	fields := parseTOMLErrorCodeFrame(codeframe)

	// Construct errors using the extracted field names.
	var errors []ErrorMeta
	for _, field := range fields {
		errMeta := ErrorMeta{
			Level:   DecodeErr,
			Field:   field,
			Message: fmt.Sprintf("Invalid field found: %s", field),
		}
		errors = append(errors, errMeta)
	}

	// Construct a validation failure.
	validationError := ValidationFailure{
		File:   filePath,
		Errors: errors,
	}

	return validationError
}

// parseTOMLErrorCodeFrame parses the codeframe generated by go-toml, and extracts field names which are associated with the error.
func parseTOMLErrorCodeFrame(codeframe string) []string {
	var fields []string
	lines := strings.Split(codeframe, "\n")

	// Compile a regular expression for matching fields.
	exp := regexp.MustCompile(codeframeFieldRegexp)

	// This is added as a safety check. pelletier/go-toml/v2 doesn't return codeframes lesser than 2 lines.
	if len(lines) < 2 {
		return []string{""}
	}

	for i := 1; i < len(lines); i++ {
		// Retrieve current and previous line from the codeframe.
		currLine := lines[i]
		prevLine := lines[i-1]

		// Check if the current line contains the "missing field" message.
		if strings.Contains(currLine, "missing field") {
			// If yes, use the codeframeFieldRegexp regular expression for matching the previous line to retrieve the field name.
			matches := exp.FindStringSubmatch(prevLine)

			// Get index for the "field" named group.
			groupIndex := exp.SubexpIndex("field")

			// Capture match. We proceed only if the groupIndex isn't -1 (group not found), and if the number of matches aren't zero.
			match := ""
			if len(matches) != 0 && groupIndex != -1 {
				match = matches[groupIndex]
			}

			// Add the field name to fields.
			field := strings.TrimSpace(match)
			fields = append(fields, field)
		}
	}

	return fields
}
