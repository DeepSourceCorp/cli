package validator

import (
	"errors"
	"fmt"
	"path"
	"reflect"
	"regexp"
	"strings"

	validate "github.com/go-playground/validator/v10"
	"github.com/pelletier/go-toml/v2"
)

// codeframeFieldRegexp is a regular expression used for matching a TOML field present in the codeframe generated by go-toml.
var codeframeFieldRegexp = `\d\s*[|].(?P<field>\w+)\s*=\s*\S*`

// Returns the list of required fields from the error message returned by the `go-playground/validator` library
func getMissingRequiredFields(err error, config interface{}) []string {
	missingRequiredFields := []string{}
	errs := err.(validate.ValidationErrors)
	for _, err := range errs {
		if err.Tag() == "required" {
			c := reflect.ValueOf(config)
			for i := 0; i < c.Type().NumField(); i++ {
				if err.Field() == c.Type().Field(i).Name {
					missingRequiredFields = append(missingRequiredFields, c.Type().Field(i).Tag.Get("toml"))
				}
			}
		}
	}
	return missingRequiredFields
}

// Handle decoding errors reported by go-toml
func handleTOMLDecodeErrors(err error, filePath string) *ValidationFailure {
	var usefulResponse, expectedType, receivedType, fieldName, decodeErrorMessage string

	// We check for go-toml's StrictMissingError, as the decoder returns a StrictMissingError when there exists a mismatch between the destination and the extracted fields.
	// go-toml doesn't return the field name associated with the error, however, StrictMissingError returns a human-readable codeframe, which can be used to extract the error-causing fields.
	// Ref: https://pkg.go.dev/github.com/pelletier/go-toml/v2#example-Decoder.DisallowUnknownFields

	var strictMissingError *toml.StrictMissingError
	if errors.As(err, &strictMissingError) {
		// Extract human-readable codeframe.
		codeframe := strictMissingError.String()

		// Retrieve field names from the codeframe.
		fields := parseCodeframe(codeframe)

		// Construct errors using the extracted field names.
		var errors []ErrorMeta
		for _, field := range fields {
			errMeta := ErrorMeta{
				Level:   DecodeErr,
				Field:   field,
				Message: fmt.Sprintf("Invalid field found: %s", field),
			}
			errors = append(errors, errMeta)
		}

		// Construct a validation failure.
		validationError := ValidationFailure{
			File:   filePath,
			Errors: errors,
		}

		return &validationError
	}

	// Get the DecodeError exported by go-toml
	// Ref: https://pkg.go.dev/github.com/pelletier/go-toml/v2#DecodeError
	var decodeErr *toml.DecodeError
	if !errors.As(err, &decodeErr) {
		decodeErrorMessage = err.Error()

		// Handle strict mode error when some alien fields are added in the user configured TOML
		if strings.HasPrefix(err.Error(), "strict mode") {
			decodeErrorMessage = fmt.Sprintf("Failed to parse %s. Invalid fields detected.", path.Base(filePath))
		}
		validationError := ValidationFailure{
			File: filePath,
			Errors: []ErrorMeta{
				{
					Level:   DecodeErr,
					Field:   "",
					Message: decodeErrorMessage,
				},
			},
		}
		return &validationError
	}

	/* =================================================
	 * Extract the data about the decoding failure and return
	 * a validation failure response
	 * ================================================= */

	errorMessage := decodeErr.Error()
	// Error case 1: `toml: cannot decode TOML integer into struct field types.AnalyzerTOML.Name of type string"`
	if strings.HasPrefix(errorMessage, "toml: cannot decode TOML") {

		usefulResponse = strings.TrimPrefix(errorMessage, "toml: cannot decode TOML ")
		responseArray := strings.Split(usefulResponse, " ")

		expectedType = responseArray[len(responseArray)-1]
		receivedType = responseArray[0]
		fieldData := responseArray[len(responseArray)-4]
		index := strings.LastIndex(fieldData, ".")
		fieldName = strings.ToLower(fieldData[index:])
		// Framing the decoding failure error message
		decodeErrorMessage = fmt.Sprintf("expected the field \"%s\" of type %s. Got %s.", fieldName, expectedType, receivedType)

	} else if strings.HasPrefix(errorMessage, "toml: cannot store TOML") {

		// Error case 2: `toml: cannot store TOML string into a Go slice`
		usefulResponse = strings.TrimPrefix(errorMessage, "toml: cannot store TOML ")
		responseArray := strings.Split(usefulResponse, " ")

		expectedType = responseArray[len(responseArray)-1]
		receivedType = responseArray[0]
		decodeErrorMessage = fmt.Sprintf("expected type for one of the fields : %s. Received: %s.", expectedType, receivedType)
	} else {
		decodeErrorMessage = errorMessage
		fieldName = ""
	}

	validationError := ValidationFailure{
		File: filePath,
		Errors: []ErrorMeta{
			{
				Level:   DecodeErr,
				Field:   fieldName,
				Message: decodeErrorMessage,
			},
		},
	}
	return &validationError
}

// parseCodeframe parses the codeframe generated by go-toml, and extracts field names which are associated with the error.
func parseCodeframe(codeframe string) []string {
	var fields []string
	lines := strings.Split(codeframe, "\n")

	// Compile a regular expression for matching fields.
	exp := regexp.MustCompile(codeframeFieldRegexp)

	// This is added as a safety check. pelletier/go-toml/v2 doesn't return codeframes lesser than 2 lines.
	if len(lines) < 2 {
		return []string{""}
	}

	for i := 1; i < len(lines); i++ {
		// Retrieve current and previous line from the codeframe.
		currLine := lines[i]
		prevLine := lines[i-1]

		// Check if the current line contains the "missing field" message.
		if strings.Contains(currLine, "missing field") {
			// If yes, use the codeframeFieldRegexp regular expression for matching the previous line to retrieve the field name.
			matches := exp.FindStringSubmatch(prevLine)

			// Get index for the "field" named group.
			groupIndex := exp.SubexpIndex("field")

			// Capture match. We proceed only if the groupIndex isn't -1 (group not found), and if the number of matches aren't zero.
			match := ""
			if len(matches) != 0 && groupIndex != -1 {
				match = matches[groupIndex]
			}

			// Add the field name to fields.
			field := strings.TrimSpace(match)
			fields = append(fields, field)
		}
	}

	return fields
}
