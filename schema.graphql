schema {
  query: Query
  mutation: Mutation
}

input AcceptGroupInviteInput {
  invitationCode: String!
  clientMutationId: String
}

type AcceptGroupInvitePayload {
  ok: Boolean
  clientMutationId: String
}

type AccessToken implements MaskPrimaryKeyNode {
  description: String!
  expiresAt: DateTime!
  lastUsedAt: DateTime
  id: ID!
  expirationStatus: AccessTokenExpirationStatus
}

type AccessTokenConnection {
  pageInfo: PageInfo!
  edges: [AccessTokenEdge]!
  totalCount: Int
}

type AccessTokenEdge {
  node: AccessToken
  cursor: String!
}

enum AccessTokenExpirationStatus {
  ACTIVE
  DOES_NOT_EXPIRE
  EXPIRED
}

enum ActionChoice {
  ADD
  REMOVE
}

input ActivateGSRRepositoryInput {
  config: String!
  defaultBranchName: String!
  repositoryId: ID!
  clientMutationId: String
}

type ActivateGSRRepositoryPayload {
  ok: Boolean
  clientMutationId: String
}

input AddAnalyzerFeedbackInput {
  feedback: String!
  analyzerShortcode: String!
  okToContact: Boolean!
  isAlreadyUsing: Boolean!
  clientMutationId: String
}

type AddAnalyzerFeedbackPayload {
  ok: Boolean
  clientMutationId: String
}

input AddTeamToGroupInput {
  groupId: ID!
  teamId: ID!
  role: TeamMemberRoleChoices
  clientMutationId: String
}

type AddTeamToGroupPayload {
  ok: Boolean
  clientMutationId: String
}

input AddTransformerFeedbackInput {
  feedback: String!
  shortcode: String!
  okToContact: Boolean!
  isAlreadyUsing: Boolean!
  clientMutationId: String
}

type AddTransformerFeedbackPayload {
  ok: Boolean
  clientMutationId: String
}

input AddUserToGroupInput {
  groupId: ID!
  userId: ID!
  clientMutationId: String
}

type AddUserToGroupPayload {
  ok: Boolean
  clientMutationId: String
}

type Analyzer implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  category: String
  documentationUrl: String
  discussUrl: String
  version: String!
  shortcode: String!
  macroPath: String
  name: String!
  accessKey: UUID!
  logo: String
  description: String!
  analyzerType: AnalyzerAnalyzerType!
  status: AnalyzerStatus!
  command: String
  autofixerCommand: String
  minCpuLimit: Int!
  minMemoryLimit: Int!
  maxCpuLimit: Int!
  maxMemoryLimit: Int!
  metaSchema: JSONString!
  runtimeVersions: [String!]!
  trigger: AnalyzerTrigger!
  repository: Repository
  owner: String
  isPrimary: Boolean!
  starIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, sort: String, issueType: String, autofixAvailable: Boolean): IssueConnection!
  exampleConfig: String
  defaultTestPatterns: [String!]!
  supportedFilesRegex: String
  issues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, sort: String, issueType: String, autofixAvailable: Boolean): IssueConnection!
  reviews(offset: Int, before: String, after: String, first: Int, last: Int): AnalyzerReviewConnection!
  checks(offset: Int, before: String, after: String, first: Int, last: Int): CheckConnection!
  repositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection!
  autofixRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection!
  transformertoolSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String, language: [String]): TransformerToolConnection!
  transformerRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TransformerRunConnection!
  analyzerLogo: String
  descriptionRendered: String
  publishedOn: Date
  updatedOn: Date
  issuesCount: Int
  autofixableIssuesCount: Int
  issueDistribution: GenericScalar
  issueTypeDistribution(q: String, sort: String, issueType: String, autofixAvailable: Boolean): GenericScalar
}

enum AnalyzerAnalyzerType {
  CORE
  COMMUNITY
  CUSTOM
}

type AnalyzerAutofixableIssues {
  analyzer: Analyzer
  filesAffected: Int
  issueCount: Int
  raisedInFiles: [String]
}

type AnalyzerConnection {
  pageInfo: PageInfo!
  edges: [AnalyzerEdge]!
  totalCount: Int
}

type AnalyzerEdge {
  node: Analyzer
  cursor: String!
}

type AnalyzerReview implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  analyzer: Analyzer!
  name: String!
  avatar: String!
  comment: String!
}

type AnalyzerReviewConnection {
  pageInfo: PageInfo!
  edges: [AnalyzerReviewEdge]!
  totalCount: Int
}

type AnalyzerReviewEdge {
  node: AnalyzerReview
  cursor: String!
}

enum AnalyzerStatus {
  ACTIVE
  DRAFT
}

enum AnalyzerTrigger {
  CODE
  DATA
}

type AppliedCoupon {
  code: String
  description: String
}

input ApplyCreditsToOwnerInput {
  id: ID
  ownerId: Int
  amount: Int!
  clientMutationId: String
}

type ApplyCreditsToOwnerPayload {
  ok: Boolean
  availableCredits: Int
  clientMutationId: String
}

input Attachment {
  base64Data: String!
  filename: String!
}

type AuditLog implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  eventName: String!
  description: String!
  actor: EnterpriseUser
  ipAddress: String
  location: String
  reason: String
  objectId: Int
}

type AuditLogConnection {
  pageInfo: PageInfo!
  edges: [AuditLogEdge]!
  totalCount: Int
}

type AuditLogEdge {
  node: AuditLog
  cursor: String!
}

type AuditLogMeta {
  possibleActors: [String]
  events: [String]
  exportFormats: [String]
}

type AutoOnboardEvent implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  pullRequestNumber: Int
  owner: Owner!
  repository: Repository!
  template: ConfigTemplate!
  createdBy: EnterpriseUser
  status: AutoOnboardEventStatus!
  vcsPrUrl: String
}

type AutoOnboardEventConnection {
  pageInfo: PageInfo!
  edges: [AutoOnboardEventEdge]!
}

type AutoOnboardEventEdge {
  node: AutoOnboardEvent
  cursor: String!
}

enum AutoOnboardEventStatus {
  PEND
  CLSD
  FAIL
  MRGD
  OPEN
}

input AutoOnboardInput {
  templateShortcode: String!
  repoIds: [ID]!
  clientMutationId: String
}

type AutoOnboardPayload {
  ok: Boolean
  clientMutationId: String
}

type AutofixRun implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  runId: UUID!
  commitOid: String
  status: AutofixRunStatus!
  finishedAt: DateTime
  errors: JSONString
  config: JSONString
  resolvedIssuesMetadata: JSONString!
  pullRequestNumber: Int
  pullRequestStatus: AutofixRunPullRequestStatus!
  committedToBranchStatus: AutofixRunCommittedToBranchStatus!
  extraData: JSONString!
  createdBy: User
  issue: Issue
  analyzer: Analyzer
  checkIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, shortcode: String, sort: String): CheckIssueConnection!
  filesAffected: Int
  issuesAffected: Int
  changeset: GenericScalar
  errorsRendered: GenericScalar
  finishedIn: Int
  vcsPrUrl: String
  resolvedIssuesCount: Int
  gitCompareDisplay: String
  isGeneratedFromPr: Boolean
  pullRequestTitle: String
  staleRedirectUrl: String
}

enum AutofixRunCommittedToBranchStatus {
  NCB
  CIP
  CTB
  CTF
}

type AutofixRunConnection {
  pageInfo: PageInfo!
  edges: [AutofixRunEdge]!
  totalCount: Int
}

type AutofixRunEdge {
  node: AutofixRun
  cursor: String!
}

enum AutofixRunPullRequestStatus {
  PNC
  PRP
  PRO
  PRM
  PRC
  PRF
}

enum AutofixRunStatus {
  PEND
  PASS
  TIMO
  CNCL
  FAIL
  STAL
}

type AutofixableIssueDetail {
  shortcode: String
  title: String
  category: String
  occurrenceCount: Int
}

type AutofixableIssuesMetadata {
  autofixableIssueCount: Int
  estimatedTimeSaved: Int
}

type BillingInfo {
  planSlug: String
  seatsTotal: Int
  seatsUsed: Int
  lastBillAmount: Float
  upcomingBillAmount: Float
  lastPaymentDate: DateTime
  upcomingPaymentDate: DateTime
  upcomingCancellationDate: DateTime
  lastInvoiceUrl: String
  couponApplied: AppliedCoupon
  activeCard: Card
  invoices: [Invoice]
  outstandingCredits: Float
  upgradePlans: [String]
  downgradePlans: [String]
  status: SubscriptionStatusChoice!
  billingEmail: String
  billingAddress: String
  cancelAtPeriodEnd: Boolean
  billingBackend: String
  pendingUpdate: Boolean
  synced: Boolean
  clientSecret: String
}

input BitbucketInstallationLandingInput {
  queryParams: GenericScalar
  clientMutationId: String
}

type BitbucketInstallationLandingPayload {
  message: String
  nextAction: NextActionChoice
  vcsProvider: VCSProviderChoices
  login: String
  clientMutationId: String
}

input CancelCodeQualitySubscriptionInput {
  id: ID
  ownerId: Int
  clientMutationId: String
}

type CancelCodeQualitySubscriptionPayload {
  ok: Boolean
  clientMutationId: String
}

type Card {
  brand: String
  endingIn: String
  expYear: Int
  expMonth: Int
}

type Changelog {
  logEntries: [ChangelogItem]
}

type ChangelogItem {
  id: ID!
  url: String!
  status: StatusOptions!
  created: String
  title: String
  labels: [ChangelogItemLabel]
  markdownDetails: String
  plaintextDetails: String
  publishedAt: String
}

type ChangelogItemLabel {
  id: String
  created: String
  entryCount: Int
  name: String
  url: String
}

type Check implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  checkSeq: Int!
  analyzer: Analyzer
  status: CheckStatus!
  run: Run!
  triggeredAt: DateTime
  finishedAt: DateTime
  resolvedIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection!
  extraData: JSONString!
  errors: GenericScalar
  metrics: JSONString!
  metricsCaptured: [RepositoryMetricValue]
  checkIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, shortcode: String, sort: String): CheckIssueConnection!
  concreteIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, sort: String, issueType: String, autofixAvailable: Boolean): IssueConnection
  finishedIn: Int
  finishedInDisplay: String
  errorsRendered: GenericScalar
  issuesRaisedCount: Int
  issuesResolvedCount: Int
  autofixableIssues: [AutofixableIssueDetail]
  filesAffectedByAutofix: Int
}

type CheckConnection {
  pageInfo: PageInfo!
  edges: [CheckEdge]!
  totalCount: Int
}

type CheckEdge {
  node: Check
  cursor: String!
}

type CheckIssue implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  checkInstance: Check!
  concreteIssue: Issue
  severity: CheckIssueSeverity!
  isSuppressed: Boolean
  path: String!
  text: String
  occurrenceType: CheckIssueOccurrenceType!
  beginLine: Int!
  beginColumn: Int!
  endLine: Int!
  endColumn: Int!
  extraData: JSONString!
  inRepositoryIssue(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection!
  autofixRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection!
  sourceCodeMarkup: String
  issueType: String
  shortcode: String
  description: String
}

type CheckIssueConnection {
  pageInfo: PageInfo!
  edges: [CheckIssueEdge]!
  totalCount: Int
}

type CheckIssueEdge {
  node: CheckIssue
  cursor: String!
}

enum CheckIssueOccurrenceType {
  EXIST
  NEW
}

enum CheckIssueSeverity {
  CRITICAL
  MAJOR
  MINOR
}

enum CheckStatus {
  PEND
  PASS
  FAIL
  TIMO
  CNCL
  READ
  NEUT
}

input CommitAdhocConfigInput {
  repositoryId: ID!
  createPullRequest: Boolean = false
  clientMutationId: String
}

type CommitAdhocConfigPayload {
  ok: Boolean
  vcsPrUrl: String
  clientMutationId: String
}

input CommitChangesToPRInput {
  patches: [Int]!
  autofixRunId: String!
  clientMutationId: String
}

type CommitChangesToPRPayload {
  ok: Boolean
  clientMutationId: String
}

input CommitConfigToVCSInput {
  config: String!
  repositoryId: ID!
  createPullRequest: Boolean = false
  clientMutationId: String
}

type CommitConfigToVCSPayload {
  ok: Boolean
  clientMutationId: String
}

type ConfigTemplate implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  owner: Owner!
  shortcode: String!
  title: String!
  description: String!
  config: JSONString!
  events(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection!
}

type ConfigTemplateConnection {
  pageInfo: PageInfo!
  edges: [ConfigTemplateEdge]!
  totalCount: Int
}

type ConfigTemplateEdge {
  node: ConfigTemplate
  cursor: String!
}

input ConfirmInvitationInput {
  action: InviteActions
  invitationCode: String!
  clientMutationId: String
}

type ConfirmInvitationPayload {
  ok: Boolean
  teamName: String
  teamLogo: String
  vcsProvider: String
  role: TeamMemberRoleChoices
  viewer: User
  message: String
  joined: Boolean
  clientMutationId: String
}

type Context {
  staticRoot: String
  apiRoot: String
  websocketUrl: String
  installationProvidersUrl: String
  installationUrls: GenericScalar
  stripePublishableKey: String
  appEnv: String
  emptyAvatarUrl: String
  debug: String
  sentryDsn: String
  userGroupUrl: String
  weeklyLiveDemoUrl: String
  onPrem: String
  deepsourceCloudProduction: String
  githubEnabled: Boolean
  gitlabEnabled: Boolean
  bitbucketEnabled: Boolean
  supportEmail: String
  isTransformersLicensed: Boolean
  toOnboard: Boolean
  plans: GenericScalar
}

type CouponInfo {
  currentCycleDiscount: Float!
  nextCycleDiscount: Float!
  isApplied: Boolean!
  description: String!
}

input CreateAccessTokenInput {
  description: String!
  expireInDays: Int
  clientMutationId: String
}

type CreateAccessTokenPayload {
  token: String
  accessToken: AccessToken
  clientMutationId: String
}

input CreateAutofixRunForAnalyzerInput {
  analyzerId: ID!
  repositoryId: ID!
  inputFiles: [String]
  clientMutationId: String
}

type CreateAutofixRunForAnalyzerPayload {
  runId: String
  clientMutationId: String
}

input CreateAutofixRunForPullRequestInput {
  checkId: ID!
  issues: [String]!
  clientMutationId: String
}

type CreateAutofixRunForPullRequestPayload {
  autofixRunId: String
  clientMutationId: String
}

input CreateAutofixRunInput {
  inputFiles: [String]!
  repoIssueId: ID!
  clientMutationId: String
}

type CreateAutofixRunPayload {
  runId: String
  clientMutationId: String
}

input CreateConfigTemplateInput {
  ownerId: ID!
  config: JSONString!
  title: String!
  description: String
  clientMutationId: String
}

type CreateConfigTemplatePayload {
  template: ConfigTemplate
  clientMutationId: String
}

input CreateGroupInput {
  name: String!
  clientMutationId: String
}

type CreateGroupPayload {
  group: EnterpriseGroup
  clientMutationId: String
}

input CreatePullRequestInput {
  patches: [Int]!
  autofixRunId: String!
  repoId: ID!
  clientMutationId: String
}

type CreatePullRequestPayload {
  ok: Boolean
  clientMutationId: String
}

input CreateWebhookInput {
  url: String!
  secret: String!
  apiSigning: Boolean!
  eventsSubscribed: [String]!
  ownerId: ID!
  clientMutationId: String
}

type CreateWebhookPayload {
  webhook: Webhook
  clientMutationId: String
}

type CreditsInfo {
  currentCycleDiscount: Float!
  nextCycleDiscount: Float!
  isApplied: Boolean!
}

scalar Date

scalar DateTime

scalar Decimal

input DeleteAccessTokenInput {
  tokenId: ID!
  clientMutationId: String
}

type DeleteAccessTokenPayload {
  ok: Boolean
  clientMutationId: String
}

input DeleteAllAccessTokensInput {
  clientMutationId: String
}

type DeleteAllAccessTokensPayload {
  ok: Boolean
  clientMutationId: String
}

input DeleteConfigTemplateInput {
  shortcode: String!
  clientMutationId: String
}

type DeleteConfigTemplatePayload {
  ok: Boolean
  clientMutationId: String
}

input DeleteGroupInput {
  groupId: ID!
  clientMutationId: String
}

type DeleteGroupPayload {
  ok: Boolean
  clientMutationId: String
}

type DeleteJSONWebTokenCookie {
  deleted: Boolean!
}

type DeleteRefreshTokenCookie {
  deleted: Boolean!
}

input DeleteSilenceRuleInput {
  silenceRuleId: ID!
  clientMutationId: String
}

type DeleteSilenceRulePayload {
  ok: Boolean
  clientMutationId: String
}

input DeleteUserInput {
  userId: ID!
  clientMutationId: String
}

type DeleteUserPayload {
  ok: Boolean
  clientMutationId: String
}

input DeleteWebhookInput {
  webhookId: ID!
  clientMutationId: String
}

type DeleteWebhookPayload {
  ok: Boolean
  clientMutationId: String
}

input DisableWebhookInput {
  webhookId: ID!
  clientMutationId: String
}

type DisableWebhookPayload {
  ok: Boolean
  clientMutationId: String
}

type Discount {
  coupon: CouponInfo
  credits: CreditsInfo
}

type EnterpriseBillingInfo {
  seatsTotal: Int
  seatsUsed: Int
  plan: String
  licenseExpiry: String
  features: GenericScalar
}

type EnterpriseGroup implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  scimId: String
  scimExternalId: String
  scimDisplayName: String
  name: String
  members(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection!
  teams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection!
  invitationCode: String
  groupusermembershipSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupUserMembershipConnection!
  groupteammembershipSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupTeamMembershipConnection!
  groupTeams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupTeamMembershipConnection
  groupUsers(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupUserMembershipConnection
  allTeams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection
  invitationUrl: String
  scimEnabled: Boolean
}

type EnterpriseGroupConnection {
  pageInfo: PageInfo!
  edges: [EnterpriseGroupEdge]!
  totalCount: Int
}

type EnterpriseGroupEdge {
  node: EnterpriseGroup
  cursor: String!
}

type EnterpriseInstallationRoot {
  installation: EnterpriseInstallationSetup
  license: License
  group(id: ID!): EnterpriseGroup
  groups(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseGroupConnection
  user(id: ID!): EnterpriseUser
  users(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection
  teams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection
  personalAccounts(offset: Int, before: String, after: String, first: Int, last: Int): OwnerConnection
  managementConsoleUrl: String
  isScimEnabled: Boolean
}

type EnterpriseInstallationSetup {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  name: String!
  logo: String
}

type EnterpriseUser implements MaskPrimaryKeyNode {
  id: ID!
  lastLogin: DateTime
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  scimId: String
  scimExternalId: String
  scimUsername: String
  email: String!
  primaryOwner: Owner
  avatar: String
  preferredTechnologies(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection!
  bookmarkedIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection!
  preference: UserPreference
  IsBetaTester: Boolean!
  socialAuth(offset: Int, before: String, after: String, first: Int, last: Int, uid: String, uid_In: [String], provider: String, provider_In: [String]): SocialNodeConnection!
  auditlogSet(offset: Int, before: String, after: String, first: Int, last: Int, actor_In: [String], created: String, createdBefore: String, createdAfter: String, ipAddress_In: [String], eventName_In: [String]): AuditLogConnection!
  primaryOwnerships(offset: Int, before: String, after: String, first: Int, last: Int): OwnerConnection!
  teams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection!
  teamMemberships(offset: Int, before: String, after: String, first: Int, last: Int, q: String, role: [String]): TeamMemberConnection!
  repositorySet(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection!
  transactions(offset: Int, before: String, after: String, first: Int, last: Int, transactionType: String): TransactionConnection!
  scimGroups(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseGroupConnection!
  groupusermembershipSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupUserMembershipConnection!
  autofixrunSet(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection!
  onboardingEvents(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection!
  repositorycollaboratorSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String, permission: String): RepositoryCollaboratorConnection!
  silenceRulesCreated(offset: Int, before: String, after: String, first: Int, last: Int, creator: ID, issueTitle: String, issueCode: String, filePath: String, silenceLevel: String): SilenceRuleConnection!
  accessTokens(offset: Int, before: String, after: String, first: Int, last: Int): AccessTokenConnection!
  isSuperuser: Boolean!
  createdAt: DateTime!
  modifiedAt: DateTime!
  fullName: String
  team(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection
  scimEnabled: Boolean
}

type EnterpriseUserConnection {
  pageInfo: PageInfo!
  edges: [EnterpriseUserEdge]!
  totalCount: Int
}

type EnterpriseUserEdge {
  node: EnterpriseUser
  cursor: String!
}

type FeatureDefinition implements MaskPrimaryKeyNode {
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  shortcode: String!
  featureType: FeatureFeatureType!
  showUpgradeCta: Boolean!
  subscribedOwners(offset: Int, before: String, after: String, first: Int, last: Int): OwnerConnection!
  id: ID!
}

enum FeatureFeatureType {
  A_1
  A_2
}

type FeatureInfo {
  feature: FeatureDefinition
  enabled: Boolean
}

input GSRInstallationLandingInput {
  login: String!
  clientMutationId: String
}

type GSRInstallationLandingPayload {
  ok: Boolean
  reauth: Boolean
  clientMutationId: String
}

type GSRProject {
  login: String
  name: String
  hasInstalled: Boolean
  isSetupPending: Boolean
}

input GenerateKeyPairForOwnerInput {
  ownerId: ID!
  clientMutationId: String
}

type GenerateKeyPairForOwnerPayload {
  publicKey: String
  clientMutationId: String
}

input GenerateKeyPairForRepositoryInput {
  repositoryId: ID!
  clientMutationId: String
}

type GenerateKeyPairForRepositoryPayload {
  repository: Repository
  clientMutationId: String
}

scalar GenericScalar

input GetBillingInfoInput {
  productSlug: String!
  planSlug: String!
  quantity: Int!
  couponCode: String
  id: ID
  ownerId: Int
  isTrial: Boolean!
  clientMutationId: String
}

type GetBillingInfoPayload {
  amountPayableThisCycle: Float!
  amountPayableNextCycle: Float!
  nextBillingCycle: DateTime!
  netPayableThisCycle: Float!
  netPayableNextCycle: Float!
  discounts: Discount!
  clientMutationId: String
}

input GetUpgradeCodeQualitySubscriptionPlanInfoInput {
  id: ID
  ownerId: Int
  planSlug: String!
  clientMutationId: String
}

type GetUpgradeCodeQualitySubscriptionPlanInfoPayload {
  endingBalance: Int
  upcomingBillAmount: Int
  upcomingBillDate: DateTime
  prorationAmount: Int
  proratedForDays: Int
  billedImmediately: Boolean
  quantity: Int
  clientMutationId: String
}

input GithubEnterpriseInstallationLandingInput {
  queryParams: GenericScalar
  clientMutationId: String
}

type GithubEnterpriseInstallationLandingPayload {
  message: String
  nextAction: NextActionChoice
  vcsProvider: VCSProviderChoices
  login: String
  clientMutationId: String
}

input GithubInstallationLandingInput {
  queryParams: GenericScalar
  clientMutationId: String
}

type GithubInstallationLandingPayload {
  message: String
  nextAction: NextActionChoice
  vcsProvider: VCSProviderChoices
  login: String
  clientMutationId: String
}

input GitlabInstallationLandingInput {
  login: String!
  clientMutationId: String
}

type GitlabInstallationLandingPayload {
  ok: Boolean
  reauth: Boolean
  clientMutationId: String
}

type GroupInviteInfo {
  name: String
}

type GroupTeamMembership implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  role: TeamMemberRoleChoices
  team: Team!
  group: EnterpriseGroup!
}

type GroupTeamMembershipConnection {
  pageInfo: PageInfo!
  edges: [GroupTeamMembershipEdge]!
  totalCount: Int
}

type GroupTeamMembershipEdge {
  node: GroupTeamMembership
  cursor: String!
}

type GroupUserMembership implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  user: EnterpriseUser!
  group: EnterpriseGroup!
}

type GroupUserMembershipConnection {
  pageInfo: PageInfo!
  edges: [GroupUserMembershipEdge]!
  totalCount: Int
}

type GroupUserMembershipEdge {
  node: GroupUserMembership
  cursor: String!
}

enum IgnoreCheckIssueActionChoice {
  SUPPRESS
  DELETE
}

input IgnoreCheckIssueInput {
  checkIssueId: ID!
  action: IgnoreCheckIssueActionChoice!
  clientMutationId: String
}

type IgnoreCheckIssuePayload {
  ok: Boolean
  clientMutationId: String
}

input IgnoreIssueForFilePatternInRepositoryInput {
  repoIssueId: ID
  checkId: ID
  issueShortcode: String
  pattern: String!
  clientMutationId: String
}

type IgnoreIssueForFilePatternInRepositoryPayload {
  ok: Boolean
  checkIssueIds: [String]
  clientMutationId: String
}

input IgnoreIssueForRepositoryInput {
  repoIssueId: ID
  checkId: ID
  issueShortcode: String
  filePath: String
  clientMutationId: String
}

type IgnoreIssueForRepositoryPayload {
  ok: Boolean
  checkIssueIds: [String]
  clientMutationId: String
}

input IgnoreIssueForTestPatternsInRepositoryInput {
  repoIssueId: ID
  checkId: ID
  issueShortcode: String
  clientMutationId: String
}

type IgnoreIssueForTestPatternsInRepositoryPayload {
  ok: Boolean
  checkIssueIds: [String]
  clientMutationId: String
}

enum InviteActions {
  VIEW
  ACCEPT
}

enum InviteTeamMemberActionChoice {
  CREATE
  CANCEL
}

input InviteTeamMemberInput {
  ownerId: Int
  ownerPk: ID
  email: String!
  action: InviteTeamMemberActionChoice!
  role: TeamMemberRoleChoices!
  clientMutationId: String
}

type InviteTeamMemberPayload {
  invitationUrl: String
  clientMutationId: String
}

input InviteTeamMembersInput {
  invitees: [Invitee]!
  ownerId: ID!
  action: InviteTeamMemberActionChoice!
  clientMutationId: String
}

type InviteTeamMembersPayload {
  ok: Boolean
  clientMutationId: String
}

input Invitee {
  email: String!
  role: TeamMemberRoleChoices!
}

type Invoice {
  invoiceId: String
  date: DateTime
  amount: Float
  url: String
}

type Issue implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  shortcode: String!
  title: String!
  description: String!
  severity: IssueSeverity!
  analyzer: Analyzer!
  autofixAvailable: Boolean!
  autofixTitle: String
  isRecommended: Boolean!
  weight: Int!
  starIssueInAnalyzers(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection!
  issuePriorities(offset: Int, before: String, after: String, first: Int, last: Int): IssuePriorityConnection!
  checkIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, shortcode: String, sort: String): CheckIssueConnection!
  autofixRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection!
  occurrenceCount: Int
  issueType: String
  seenIn: String
  descriptionRendered: String
  shortDescription: String
  shortDescriptionRendered: String
  issuePriority(repositoryId: ID!): IssuePriority
}

type IssueConnection {
  pageInfo: PageInfo!
  edges: [IssueEdge]!
  totalCount: Int
}

type IssueEdge {
  node: Issue
  cursor: String!
}

type IssuePriority implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  issuePriorityType: IssuePriorityType!
  concreteIssue: Issue!
  repository: Repository
  owner: Owner
  repositoryIssuePriority: IssuePriorityType
}

type IssuePriorityConnection {
  pageInfo: PageInfo!
  edges: [IssuePriorityEdge]!
}

type IssuePriorityEdge {
  node: IssuePriority
  cursor: String!
}

type IssuePrioritySetting {
  slug: String
  weight: Int
  verboseName: String
  isIgnoredInCheckStatus: Boolean
  isIgnoredToDisplay: Boolean
}

type IssuePriorityType implements Node {
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  weight: Int
  slug: String
  verboseName: String
  issuePriorities(offset: Int, before: String, after: String, first: Int, last: Int): IssuePriorityConnection!
  id: ID!
}

type IssuePriorityTypeConnection {
  pageInfo: PageInfo!
  edges: [IssuePriorityTypeEdge]!
  totalCount: Int
}

type IssuePriorityTypeEdge {
  node: IssuePriorityType
  cursor: String!
}

enum IssueSeverity {
  CRITICAL
  MAJOR
  MINOR
}

type IssueTypeSetting {
  slug: String
  name: String
  isIgnoredInCheckStatus: Boolean
  isIgnoredToDisplay: Boolean
  description: String
}

input IssueTypeSettingInput {
  slug: String
  name: String
  isIgnoredInCheckStatus: Boolean
  isIgnoredToDisplay: Boolean
  description: String
}

scalar JSONString

type License {
  seatsTotal: Int
  seatsUsed: Int
  plan: String
  licenseExpiry: String
  seatUsageTrend(lastDays: Int!, trendType: TrendType!): GenericScalar
}

input LogOutInput {
  clientMutationId: String
}

type LogOutPayload {
  ok: Boolean
  clientMutationId: String
}

interface MaskPrimaryKeyNode {
  id: ID!
}

type Mutation {
  updateEnterpriseInstallation(input: UpdateEnterpriseInstallationInput!): UpdateEnterpriseInstallationPayload
  createGroup(input: CreateGroupInput!): CreateGroupPayload
  updateGroup(input: UpdateGroupInput!): UpdateGroupPayload
  deleteGroup(input: DeleteGroupInput!): DeleteGroupPayload
  resetGroupInvitationLink(input: ResetGroupInvitationLinkInput!): ResetGroupInvitationLinkPayload
  addUserToGroup(input: AddUserToGroupInput!): AddUserToGroupPayload
  removeUserFromGroup(input: RemoveUserFromGroupInput!): RemoveUserFromGroupPayload
  addTeamToGroup(input: AddTeamToGroupInput!): AddTeamToGroupPayload
  removeTeamFromGroup(input: RemoveTeamFromGroupInput!): RemoveTeamFromGroupPayload
  updateGroupTeamRole(input: UpdateGroupTeamRoleInput!): UpdateGroupTeamRolePayload
  toggleUserActive(input: ToggleUserActiveInput!): ToggleUserActivePayload
  deleteUser(input: DeleteUserInput!): DeleteUserPayload
  acceptGroupInvite(input: AcceptGroupInviteInput!): AcceptGroupInvitePayload
  socialAuth(code: String!, provider: String!): SocialAuthJWT
  revokeToken(refreshToken: String): Revoke
  deleteTokenCookie: DeleteJSONWebTokenCookie
  deleteRefreshTokenCookie: DeleteRefreshTokenCookie
  logout(input: LogOutInput!): LogOutPayload
  switchToAsgard(input: SwitchToAsgardInput!): SwitchToAsgardPayload
  verifyToken(token: String): Verify
  refreshToken(refreshToken: String): RefreshToken
  toggleRepositoryActivation(input: ToggleRepositoryActivationInput!): ToggleRepositoryActivationPayload
  updateRepositorySettings(input: UpdateRepositorySettingsInput!): UpdateRepositorySettingsPayload
  updateOwnerSettings(input: UpdateOwnerSettingsInput!): UpdateOwnerSettingsPayload
  getBillingInfo(input: GetBillingInfoInput!): GetBillingInfoPayload
  ignoreIssueForRepository(input: IgnoreIssueForRepositoryInput!): IgnoreIssueForRepositoryPayload
  ignoreIssueForFilePatternInRepository(input: IgnoreIssueForFilePatternInRepositoryInput!): IgnoreIssueForFilePatternInRepositoryPayload
  ignoreIssueForTestPatternsInRepository(input: IgnoreIssueForTestPatternsInRepositoryInput!): IgnoreIssueForTestPatternsInRepositoryPayload
  reportIssueFalsePositive(input: ReportIssueFalsePositiveInput!): ReportIssueFalsePositivePayload
  ignoreCheckIssue(input: IgnoreCheckIssueInput!): IgnoreCheckIssuePayload
  generateKeyPairForRepository(input: GenerateKeyPairForRepositoryInput!): GenerateKeyPairForRepositoryPayload
  removeKeyPairForRepository(input: RemoveKeyPairForRepositoryInput!): RemoveKeyPairForRepositoryPayload
  generateKeyPairForOwner(input: GenerateKeyPairForOwnerInput!): GenerateKeyPairForOwnerPayload
  removeKeyPairForOwner(input: RemoveKeyPairForOwnerInput!): RemoveKeyPairForOwnerPayload
  updateRepositoryWidgets(input: UpdateRepositoryWidgetsInput!): UpdateRepositoryWidgetsPayload
  deleteSilenceRule(input: DeleteSilenceRuleInput!): DeleteSilenceRulePayload
  updateDefaultDashboardContextForUser(input: UpdateDefaultDashboardContextForUserInput!): UpdateDefaultDashboardContextForUserPayload
  updateBillingInfo(input: UpdateBillingInfoInput!): UpdateBillingInfoPayload
  subscriptionCheckout(input: SubscriptionCheckoutInput!): SubscriptionCheckoutPayload
  updateDefaultPaymentSource(input: UpdateDefaultPaymentSourceInput!): UpdateDefaultPaymentSourcePayload
  cancelCodeQualitySubscription(input: CancelCodeQualitySubscriptionInput!): CancelCodeQualitySubscriptionPayload
  updateCodeQualitySubscriptionSeats(input: UpdateCodeQualitySubscriptionSeatsInput!): UpdateCodeQualitySubscriptionSeatsPayload
  getUpgradeCodeQualitySubscriptionPlanInfo(input: GetUpgradeCodeQualitySubscriptionPlanInfoInput!): GetUpgradeCodeQualitySubscriptionPlanInfoPayload
  subscriptionPlanSwitch(input: SubscriptionPlanSwitchInput!): SubscriptionPlanSwitchPayload
  revertSubscriptionCancellation(input: RevertSubscriptionCancellationInput!): RevertSubscriptionCancellationPayload
  applyCreditsToOwner(input: ApplyCreditsToOwnerInput!): ApplyCreditsToOwnerPayload
  inviteTeamMember(input: InviteTeamMemberInput!): InviteTeamMemberPayload
  inviteTeamMembers(input: InviteTeamMembersInput!): InviteTeamMembersPayload
  removeTeamMember(input: RemoveTeamMemberInput!): RemoveTeamMemberPayload
  updateTeamMemberRole(input: UpdateTeamMemberRoleInput!): UpdateTeamMemberRolePayload
  syncRepositoriesForOwner(input: SyncRepositoriesForOwnerInput!): SyncRepositoriesForOwnerPayload
  createAutofixRun(input: CreateAutofixRunInput!): CreateAutofixRunPayload
  createdPullRequest(input: CreatePullRequestInput!): CreatePullRequestPayload
  commitConfigToVcs(input: CommitConfigToVCSInput!): CommitConfigToVCSPayload
  updateRepoMetricThreshold(input: UpdateRepoMetricThresholdInput!): UpdateRepoMetricThresholdPayload
  createAutofixRunForPullRequest(input: CreateAutofixRunForPullRequestInput!): CreateAutofixRunForPullRequestPayload
  createAutofixRunForAnalyzer(input: CreateAutofixRunForAnalyzerInput!): CreateAutofixRunForAnalyzerPayload
  commitChangesToPr(input: CommitChangesToPRInput!): CommitChangesToPRPayload
  commitAdhocConfig(input: CommitAdhocConfigInput!): CommitAdhocConfigPayload
  resetInvitationLink(input: ResetTeamInvitationLinkInput!): ResetTeamInvitationLinkPayload
  updateTeamBasePermissions(input: UpdateTeamBasePermissionsInput!): UpdateTeamBasePermissionsPayload
  addAnalyzerFeedback(input: AddAnalyzerFeedbackInput!): AddAnalyzerFeedbackPayload
  addTransformerFeedback(input: AddTransformerFeedbackInput!): AddTransformerFeedbackPayload
  updateAccessControlSettings(input: UpdateAccessControlSettingsInput!): UpdateAccessControlSettingsPayload
  syncVcsPermissions(input: SyncVcsPermissionsInput!): SyncVcsPermissionsPayload
  updateOrCreateRepositoryCollaborator(input: UpdateOrCreateRepositoryCollaboratorInput!): UpdateOrCreateRepositoryCollaboratorPayload
  removeRepositoryCollaborator(input: RemoveRepositoryCollaboratorInput!): RemoveRepositoryCollaboratorPayload
  triggerAnalysisForRepository(input: TriggerAnalysisForRepositoryInput!): TriggerAnalysisForRepositoryPayload
  updateTechnologyPreference(input: UpdateTechnologyPreferenceInput!): UpdateTechnologyPreferencePayload
  updateBookmarkedIssue(input: UpdateBookmarkedIssueInput!): UpdateBookmarkedIssuePayload
  triggerAdhocRun(input: TriggerAdHocRunInput!): TriggerAdHocRunPayload
  activateGsrRepository(input: ActivateGSRRepositoryInput!): ActivateGSRRepositoryPayload
  installation(input: GithubInstallationLandingInput!): GithubInstallationLandingPayload
  gheInstallationLanding(input: GithubEnterpriseInstallationLandingInput!): GithubEnterpriseInstallationLandingPayload
  bitbucketInstallationLanding(input: BitbucketInstallationLandingInput!): BitbucketInstallationLandingPayload
  gitlabInstallationLanding(input: GitlabInstallationLandingInput!): GitlabInstallationLandingPayload
  gsrInstallationLanding(input: GSRInstallationLandingInput!): GSRInstallationLandingPayload
  updateStarredRepository(input: UpdateStarredRepositoryInput!): UpdateStarredRepositoryPayload
  updateWatchedRepository(input: UpdateWatchedRepositoryInput!): UpdateWatchedRepositoryPayload
  confirmInvitation(input: ConfirmInvitationInput!): ConfirmInvitationPayload
  verifyDevice(input: VerifyDeviceInput!): VerifyDevicePayload
  createConfigTemplate(input: CreateConfigTemplateInput!): CreateConfigTemplatePayload
  updateConfigTemplate(input: UpdateConfigTemplateInput!): UpdateConfigTemplatePayload
  deleteConfigTemplate(input: DeleteConfigTemplateInput!): DeleteConfigTemplatePayload
  autoOnboard(input: AutoOnboardInput!): AutoOnboardPayload
  submitSupportTicket(input: SubmitSupportTicketInput!): SubmitSupportTicketPayload
  createWebhook(input: CreateWebhookInput!): CreateWebhookPayload
  testWebhook(input: TestWebhookInput!): TestWebhookPayload
  updateWebhook(input: UpdateWebhookInput!): UpdateWebhookPayload
  disableWebhook(input: DisableWebhookInput!): DisableWebhookPayload
  deleteWebhook(input: DeleteWebhookInput!): DeleteWebhookPayload
  createAccessToken(input: CreateAccessTokenInput!): CreateAccessTokenPayload
  updateAccessToken(input: UpdateAccessTokenInput!): UpdateAccessTokenPayload
  rotateAccessToken(input: RotateAccessTokenInput!): RotateAccessTokenPayload
  deleteAccessToken(input: DeleteAccessTokenInput!): DeleteAccessTokenPayload
  deleteAllAccessTokens(input: DeleteAllAccessTokensInput!): DeleteAllAccessTokensPayload
  webhookSecret(input: WebhookSecretInput!): WebhookSecretPayload
  verifyGsrPermissions(input: VerifyGSRPermissionsInput!): VerifyGSRPermissionsPayload
  verifyGsrWebhooks(input: VerifyGSRWebhooksInput!): VerifyGSRWebhooksPayload
  triggerVerifyGsrSsh(input: TriggerVerifyGSRSSHInput!): TriggerVerifyGSRSSHPayload
  verifyGsrSetup(input: VerifyGSRSetupInput!): VerifyGSRSetupPayload
  updateIssuePriority(input: UpdateIssuePriorityInput!): UpdateIssuePriorityPayload
  unsetIssuePriority(input: UnsetIssuePriorityInput!): UnsetIssuePriorityPayload
}

enum NextActionChoice {
  GITHUB_LOGIN
  DASHBOARD
  ONBOARD
  LOGIN
}

interface Node {
  id: ID!
}

type Owner implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  login: String!
  avatar: String
  vcsProvider: OwnerVcsProvider!
  vcsAccountUid: String!
  plan: OwnerPlan
  billingEmail: String
  billingAddress: String
  customerId: String
  primaryUser: EnterpriseUser
  features: GenericScalar
  gsrSetupPending: Boolean!
  analyzers(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection!
  issuePriorities(offset: Int, before: String, after: String, first: Int, last: Int): IssuePriorityConnection!
  team: Team
  repositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection
  userSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection!
  configTemplates(offset: Int, before: String, after: String, first: Int, last: Int, shortcode: String, title_Icontains: String): ConfigTemplateConnection
  onboardingEvents(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection!
  ownerSetting: OwnerSetting
  webhooks(offset: Int, before: String, after: String, first: Int, last: Int): WebhookConnection!
  isAutofixEnabled: Boolean
  autofixInstallationUrl: String
  isTeam: Boolean
  cards: GenericScalar
  stripeInvoices: GenericScalar
  numMembersTotal: Int
  billingInfo: BillingInfo
  enterpriseBillingInfo: EnterpriseBillingInfo
  activeCard: Card
  hasPremiumPlan: Boolean
  hasSubscribedToPlan: Boolean
  planUpgradeUrl: String
  isViewerPrimaryUser: Boolean
  setting: OwnerSetting
  hasGrantedAllRepoAccess: Boolean
  appConfigurationUrl: String
  featureConfig: [FeatureInfo]
  autofixedIssueTrend(lastDays: Int!): GenericScalar
  issueTrend(lastDays: Int!): GenericScalar
  resolvedIssueTrend(lastDays: Int!): GenericScalar
  accountSetupStatus: GenericScalar
  subscribedPlanInfo: GenericScalar
  vcsUrl: String
  vcsInstallationId: String
  canOnboard: Boolean
  configTemplate(shortcode: String!): ConfigTemplate
  isAutoonboardAllowed: Boolean
  autoonboardableRepositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection
  autoonboardingEvents(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection
  accessTokens(offset: Int, before: String, after: String, first: Int, last: Int): AccessTokenConnection
  maxUsagePercentage: Float
  featureUsage: GenericScalar
  isGsrSshRegistered: Boolean
}

type OwnerConnection {
  pageInfo: PageInfo!
  edges: [OwnerEdge]!
}

type OwnerEdge {
  node: Owner
  cursor: String!
}

enum OwnerPlan {
  FREE
  DEVELOPER
  TEAM
}

type OwnerSetting implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  owner: Owner!
  publicKey: String
  privateKey: String
  issueTypeSettings: [IssueTypeSetting]
}

enum OwnerVcsProvider {
  GH
  GL
  BB
  GHE
  GSR
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  changelog: Changelog
  isViewerSuperadmin: Boolean
  getGroupInviteInfo(invitationCode: String!): GroupInviteInfo
  enterprise: EnterpriseInstallationRoot
  accessToken(tokenId: ID!): AccessToken
  webhookEventTypes(offset: Int, before: String, after: String, first: Int, last: Int): WebhookEventTypesConnection
  webhookEventDeliveries(ownerId: ID!, offset: Int, before: String, after: String, first: Int, last: Int): WebhookEventDeliveryConnection
  webhookEventDelivery(ownerId: ID!, deliveryId: ID!): WebhookEventDelivery
  webhook(webhookId: ID!): Webhook
  webhooks(ownerId: ID!, offset: Int, before: String, after: String, first: Int, last: Int): WebhookConnection
  transformer(shortcode: String!): TransformerTool
  transformers(offset: Int, before: String, after: String, first: Int, last: Int, q: String, language: [String]): TransformerToolConnection
  transformerRun(runId: String!): TransformerRun!
  autofixRun(runId: String!): AutofixRun!
  oauth: SocialAuthURL
  issuePriorityType(offset: Int, before: String, after: String, first: Int, last: Int, weight: Int, verboseName: String, slug: String): IssuePriorityTypeConnection
  issue(shortcode: String!): Issue
  issuesWithPriority(isRepositoryIssuePrioritySet: Boolean!, repositoryId: ID, analyzerShortcode: String, offset: Int, before: String, after: String, first: Int, last: Int, q: String, sort: String, issueType: String, autofixAvailable: Boolean): IssueConnection
  transactions(userId: Int!, offset: Int, before: String, after: String, first: Int, last: Int, transactionType: String): TransactionConnection
  owner(login: String!, provider: VCSProviderChoices!): Owner
  team(login: String!, provider: VCSProviderChoices!): Team
  fileIssues(repoId: ID!, filepath: String!, offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection
  checkIssues(checkId: ID!, offset: Int, before: String, after: String, first: Int, last: Int, q: String, shortcode: String, sort: String): CheckIssueConnection
  check(checkId: ID!): Check!
  analyzer(shortcode: String!): Analyzer
  analyzers(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection
  viewer: User
  repositoryIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection
  repository(name: String!, owner: String!, provider: VCSProviderChoices!): Repository
  trendingRepositories(count: Int = 5, offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection
  editorsPickRepository: Repository
  discoverRepositories(preferredTechnologies: [ID] = [], q: String = "", offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection
  context: Context
  node(id: ID!): MaskPrimaryKeyNode
}

type RefreshToken {
  payload: GenericScalar!
  refreshExpiresIn: Int!
  token: String!
  refreshToken: String!
}

input RemoveKeyPairForOwnerInput {
  ownerId: ID!
  clientMutationId: String
}

type RemoveKeyPairForOwnerPayload {
  ok: Boolean
  clientMutationId: String
}

input RemoveKeyPairForRepositoryInput {
  repositoryId: ID!
  clientMutationId: String
}

type RemoveKeyPairForRepositoryPayload {
  ok: Boolean
  clientMutationId: String
}

input RemoveRepositoryCollaboratorInput {
  repositoryCollaboratorId: ID!
  clientMutationId: String
}

type RemoveRepositoryCollaboratorPayload {
  ok: Boolean
  clientMutationId: String
}

input RemoveTeamFromGroupInput {
  groupId: ID!
  teamId: ID!
  clientMutationId: String
}

type RemoveTeamFromGroupPayload {
  ok: Boolean
  clientMutationId: String
}

input RemoveTeamMemberInput {
  ownerId: Int
  ownerPk: ID
  memberEmail: String!
  clientMutationId: String
}

type RemoveTeamMemberPayload {
  ok: Boolean
  clientMutationId: String
}

input RemoveUserFromGroupInput {
  groupId: ID!
  userId: ID!
  clientMutationId: String
}

type RemoveUserFromGroupPayload {
  ok: Boolean
  clientMutationId: String
}

input ReportIssueFalsePositiveInput {
  checkIssueId: ID!
  comment: String
  clientMutationId: String
}

type ReportIssueFalsePositivePayload {
  ok: Boolean
  clientMutationId: String
}

type Repository implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  name: String!
  description: String
  vcsType: RepositoryVcsType!
  vcsProvider: VCSProviderChoices!
  vcsUrl: String!
  vcsRepoUid: String!
  collaborators(offset: Int, before: String, after: String, first: Int, last: Int, q: String, permission: String): RepositoryCollaboratorConnection
  vcsCreatedAt: DateTime
  sshUrl: String!
  defaultBranchName: String
  latestCommitOid: String
  latestAnalysisRun: Run
  isFork: Boolean!
  isMirror: Boolean!
  isPrivate: Boolean!
  showInDiscover: Boolean!
  languages: GenericScalar!
  isActivated: Boolean!
  errorCode: Int!
  errorMessage: String
  errorCtaButtonText: String
  errorCtaButtonUrl: String
  accessToken: UUID!
  encPublicKey: String
  isSubmoduleEnabled: Boolean!
  analyzeChangesetOnly: Boolean!
  issues(all: Boolean = false, offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection
  config: GenericScalar!
  owner: Owner!
  widgets: [String]
  supportedAnalyzers: [String]
  token: String!
  extraData: JSONString!
  weightCutoff: Int!
  tree: JSONString!
  latestTrainedRun: Run
  primaryAnalyzer: Analyzer
  majorityAnalyzer: Analyzer
  analyzer: Analyzer
  issuePriorities(offset: Int, before: String, after: String, first: Int, last: Int): IssuePriorityConnection!
  checks(offset: Int, before: String, after: String, first: Int, last: Int): CheckConnection!
  userpreferenceSet(offset: Int, before: String, after: String, first: Int, last: Int): UserPreferenceConnection!
  watchedBy(offset: Int, before: String, after: String, first: Int, last: Int): UserPreferenceConnection!
  autofixRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection
  transformerRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TransformerRunConnection
  onboardingEvents(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection!
  runs(offset: Int, before: String, after: String, first: Int, last: Int, status: String): RunConnection
  repositorycollaboratorSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String, permission: String): RepositoryCollaboratorConnection!
  silenceRules(offset: Int, before: String, after: String, first: Int, last: Int, creator: ID, issueTitle: String, issueCode: String, filePath: String, silenceLevel: String): SilenceRuleConnection
  ownerLogin: String
  canBeActivated: Boolean
  lastAnalyzedAt: DateTime
  blobUrlRoot: String
  fullName: String
  renderedErrorMessage: String
  activityModality: String
  issueTypeSettings: [IssueTypeSetting]
  issuePrioritySettings: [IssuePrioritySetting]
  widgetsDisplay: GenericScalar
  allWidgets: GenericScalar
  widgetsAvailable: [String]
  isAutofixEnabled: Boolean
  availableAnalyzers(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection
  metricsData(lastDays: Int!): GenericScalar
  uniqueNamespaceKeys: [String]
  isCommitPossible: Boolean
  vcsHost: String
  configGenerationRoute: String
  activeIssueCount: Int
  vcsDefaultBranchUrl: String
  issue(shortcode: String!): RepositoryIssue
  lastRun: Run
  groupedRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String): RunConnection
  autofixRun(runId: String!): AutofixRun
  groupedTransformerRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TransformerRunConnection
  transformerBranchRuns(branchName: String!, offset: Int, before: String, after: String, first: Int, last: Int, status: String): TransformerRunConnection
  transformerRun(runId: String!): TransformerRun
  run(runId: String!): Run
  branchRuns(branchName: String!, offset: Int, before: String, after: String, first: Int, last: Int, status: String): RunConnection
  hasViewerEditAccess: Boolean
  viewerPermission: RepositoryPermissionChoices
  autofixGithubAppInstallationUrl: String
  autofixBitbucketAddonInstallationUrl: String
  addableMembers(offset: Int, before: String, after: String, first: Int, last: Int, q: String, role: [String]): TeamMemberConnection
  dsn: String
  hasTestCoverage: Boolean
  badge: GenericScalar!
  logs(offset: Int, before: String, after: String, first: Int, last: Int, actor_In: [String], created: String, createdBefore: String, createdAfter: String, ipAddress_In: [String], eventName_In: [String]): AuditLogConnection
  auditLogMeta: AuditLogMeta
  issueTrend(lastDays: Int!): GenericScalar
  resolvedIssueTrend(lastDays: Int!): GenericScalar
  autofixableIssuesPerAnalyzer: [AnalyzerAutofixableIssues]
  autofixedIssueTrend(lastDays: Int!): GenericScalar
  autofixableIssuesMetadata: AutofixableIssuesMetadata
  userPermissionMeta: GenericScalar
  issueTypeDistribution(issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): [GenericScalar]
  alertingMetrics: GenericScalar
  recommendedIssueCount: Int
  totalIssueCount: Int
  isStarred: Boolean
  isWatched: Boolean
  hasAdhocRuns: Boolean
  hasHacktoberfestEnabled: Boolean
}

type RepositoryCollaborator implements MaskPrimaryKeyNode {
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  id: ID!
  repository: Repository!
  user: EnterpriseUser!
  permission: RepositoryCollaboratorPermission!
}

type RepositoryCollaboratorConnection {
  pageInfo: PageInfo!
  edges: [RepositoryCollaboratorEdge]!
  totalCount: Int
}

type RepositoryCollaboratorEdge {
  node: RepositoryCollaborator
  cursor: String!
}

enum RepositoryCollaboratorPermission {
  READ
  WRITE
  ADMIN
}

type RepositoryConnection {
  pageInfo: PageInfo!
  edges: [RepositoryEdge]!
  totalCount: Int
}

type RepositoryEdge {
  node: Repository
  cursor: String!
}

type RepositoryIssue implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  repositoryInstance: Repository!
  checkIssues(offset: Int, before: String, after: String, first: Int, last: Int, q: String, shortcode: String, sort: String): CheckIssueConnection!
  shouldIgnore: Boolean!
  severity: RepositoryIssueSeverityChoices!
  lastSeen: DateTime
  weight: Int!
  checkSet(offset: Int, before: String, after: String, first: Int, last: Int): CheckConnection!
  userSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection!
  issueType: String
  title: String
  shortcode: String
  description: String
  descriptionRendered: String
  occurrenceCount: Int
  firstSeen: DateTime
  analyzerName: String
  analyzerShortcode: String
  analyzerLogo: String
  seenIn: String
  pastValue: Int
  autofixAvailable: Boolean
  raisedInFiles: [String]
  silenceRules: [SilenceRule]
  newVcsIssueUrl: String
  lastActivity: String
}

type RepositoryIssueConnection {
  pageInfo: PageInfo!
  edges: [RepositoryIssueEdge]!
  totalCount: Int
}

type RepositoryIssueEdge {
  node: RepositoryIssue
  cursor: String!
}

input RepositoryIssuePrioritySettingsInput {
  slug: String
  weight: Int
  verboseName: String
  isIgnoredInCheckStatus: Boolean
  isIgnoredToDisplay: Boolean
}

enum RepositoryIssueSeverityChoices {
  CRITICAL
  MAJOR
  MINOR
}

type RepositoryMetricValue implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  value: Decimal!
  extraData: JSONString!
  commitOid: String!
  checkInstance: Check!
  branchName: String
  name: String
  valueDisplay: String
  isPassing: Boolean
  namespace: GenericScalar
}

enum RepositoryPermissionChoices {
  READ
  WRITE
  ADMIN
}

enum RepositoryVcsType {
  GIT
  SVN
  HG
}

input ResetGroupInvitationLinkInput {
  groupId: ID!
  clientMutationId: String
}

type ResetGroupInvitationLinkPayload {
  invitationUrl: String
  clientMutationId: String
}

input ResetTeamInvitationLinkInput {
  ownerId: ID!
  clientMutationId: String
}

type ResetTeamInvitationLinkPayload {
  invitationUrl: String
  clientMutationId: String
}

input RevertSubscriptionCancellationInput {
  id: ID
  ownerId: Int
  clientMutationId: String
}

type RevertSubscriptionCancellationPayload {
  ok: Boolean
  clientMutationId: String
}

type Revoke {
  revoked: Int!
}

input RotateAccessTokenInput {
  tokenId: ID!
  clientMutationId: String
}

type RotateAccessTokenPayload {
  token: String
  clientMutationId: String
}

type Run implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  runId: UUID!
  status: RunStatus!
  branchName: String
  baseOid: String
  commitOid: String
  finishedAt: DateTime
  errorMeta: JSONString
  config: GenericScalar
  extraData: JSONString!
  checks(offset: Int, before: String, after: String, first: Int, last: Int): CheckConnection!
  finishedIn: Int
  vcsCommitUrl: String
  gitCompareDisplay: String
  pullRequestNumberDisplay: String
  issuesRaisedCount: Int
  issuesResolvedNum: Int
  isForDefaultBranch: Boolean
  isForCrossRepoPr: Boolean
  branchRunCount: Int
  vcsPrUrl: String
  blobUrlRoot: String
}

type RunConnection {
  pageInfo: PageInfo!
  edges: [RunEdge]!
  totalCount: Int
}

type RunEdge {
  node: Run
  cursor: String!
}

enum RunStatus {
  PEND
  PASS
  FAIL
  TIMO
  CNCL
  READ
}

type SilenceRule implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  silenceLevel: SilenceRuleSilenceLevel!
  filePath: String
  repository: Repository!
  issue: Issue!
  creator: EnterpriseUser
  objectId: Int!
  metadata: GenericScalar
}

type SilenceRuleConnection {
  pageInfo: PageInfo!
  edges: [SilenceRuleEdge]!
  totalCount: Int
}

type SilenceRuleEdge {
  node: SilenceRule
  cursor: String!
}

enum SilenceRuleSilenceLevel {
  FL
  RL
}

type SocialAuthJWT {
  social: SocialType
  token: String
  refreshToken: String
  tokenExpiresIn: Int
  refreshExpiresIn: Int
}

type SocialAuthURL {
  socialUrls: GenericScalar
}

scalar SocialCamelJSON

type SocialNode implements Node {
  id: ID!
  user: EnterpriseUser!
  provider: String!
  uid: String!
  extraData: SocialCamelJSON
  created: DateTime!
  modified: DateTime!
}

type SocialNodeConnection {
  pageInfo: PageInfo!
  edges: [SocialNodeEdge]!
}

type SocialNodeEdge {
  node: SocialNode
  cursor: String!
}

type SocialType {
  id: ID!
  user: EnterpriseUser!
  provider: String!
  uid: String!
  extraData: SocialCamelJSON
  created: DateTime!
  modified: DateTime!
}

enum StatusOptions {
  PUBLISHED
  DRAFT
  PLANNED
}

input SubmitSupportTicketInput {
  fromEmail: String!
  ccEmails: String
  subject: String!
  body: String!
  attachments: [Attachment]
  clientMutationId: String
}

type SubmitSupportTicketPayload {
  ok: Boolean
  clientMutationId: String
}

input SubscriptionCheckoutInput {
  email: String!
  name: String!
  token: String!
  coupon: String!
  seats: Int!
  installationId: String!
  planSlug: String!
  clientMutationId: String
}

type SubscriptionCheckoutPayload {
  nextAction: String
  clientSecret: String
  clientMutationId: String
}

input SubscriptionPlanSwitchInput {
  id: ID
  planSlug: String!
  clientMutationId: String
}

type SubscriptionPlanSwitchPayload {
  ok: Boolean
  clientMutationId: String
}

enum SubscriptionStatusChoice {
  ACTIVE
  INACTIVE
  TRIAL
  PAST_DUE
  SCA_REQUIRED
}

input SwitchToAsgardInput {
  clientMutationId: String
}

type SwitchToAsgardPayload {
  ok: Boolean
  clientMutationId: String
}

input SyncRepositoriesForOwnerInput {
  ownerId: ID!
  clientMutationId: String
}

type SyncRepositoriesForOwnerPayload {
  ok: Boolean
  clientMutationId: String
}

input SyncVcsPermissionsInput {
  teamId: ID!
  clientMutationId: String
}

type SyncVcsPermissionsPayload {
  ok: Boolean
  clientMutationId: String
}

type Team implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  login: String!
  avatar: String
  vcsProvider: OwnerVcsProvider!
  vcsAccountUid: String!
  plan: OwnerPlan
  billingEmail: String
  billingAddress: String
  customerId: String
  primaryUser: EnterpriseUser
  gsrSetupPending: Boolean!
  ownerPtr: Owner!
  name: String!
  members(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseUserConnection!
  invitationCode: String
  syncPermissionsWithVcs: Boolean!
  teammemberSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String, role: [String]): TeamMemberConnection!
  teammemberinvitationSet(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TeamMemberInvitationConnection!
  groupSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseGroupConnection!
  groupteammembershipSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupTeamMembershipConnection!
  basePermissionSet: TeamBasePermissionSet
  billingDetails: GenericScalar
  numMembersTotal: Int
  isViewerPrimaryUser: Boolean
  teamMembers(offset: Int, before: String, after: String, first: Int, last: Int, q: String, role: [String]): TeamMemberConnection
  invites(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TeamMemberInvitationConnection
  invitationUrl: String
  logs(offset: Int, before: String, after: String, first: Int, last: Int, actor_In: [String], created: String, createdBefore: String, createdAfter: String, ipAddress_In: [String], eventName_In: [String]): AuditLogConnection
  auditLogMeta: AuditLogMeta
  accountSetupStatus: GenericScalar
  roleInGroup: TeamMemberRoleChoices
  isDirectMember: Boolean
}

type TeamBasePermissionSet implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  team: Team!
  defaultRepositoryPermission: TeamBasePermissionSetDefaultRepositoryPermission
  canMembersIgnoreIssues: Boolean!
  canMembersModifyMetricThresholds: Boolean!
  canContributorsIgnoreIssues: Boolean!
  canContributorsModifyMetricThresholds: Boolean!
}

enum TeamBasePermissionSetDefaultRepositoryPermission {
  READ
  WRITE
  ADMIN
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  totalCount: Int
}

type TeamEdge {
  node: Team
  cursor: String!
}

type TeamMember implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  role: TeamMemberRoleChoices
  team: Team!
  user: EnterpriseUser!
  isPrimaryUser: Boolean
}

type TeamMemberConnection {
  pageInfo: PageInfo!
  edges: [TeamMemberEdge]!
  totalCount: Int
}

type TeamMemberEdge {
  node: TeamMember
  cursor: String!
}

type TeamMemberInvitation implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  role: TeamMemberRoleChoices
  team: Team!
  invitationCode: String!
  email: String!
  status: TeamMemberInvitationStatus!
}

type TeamMemberInvitationConnection {
  pageInfo: PageInfo!
  edges: [TeamMemberInvitationEdge]!
  totalCount: Int
}

type TeamMemberInvitationEdge {
  node: TeamMemberInvitation
  cursor: String!
}

enum TeamMemberInvitationStatus {
  PEND
  ACTD
}

enum TeamMemberRoleChoices {
  ADMIN
  MEMBER
  CONTRIBUTOR
}

input TestWebhookInput {
  webhookId: ID!
  clientMutationId: String
}

type TestWebhookPayload {
  ok: Boolean
  clientMutationId: String
}

input ToggleRepositoryActivationInput {
  isActivated: Boolean!
  id: ID!
  clientMutationId: String
}

type ToggleRepositoryActivationPayload {
  repository: Repository
  clientMutationId: String
}

input ToggleUserActiveInput {
  userId: ID!
  isActive: Boolean!
  clientMutationId: String
}

type ToggleUserActivePayload {
  ok: Boolean
  clientMutationId: String
}

type Transaction implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  transactionType: TransactionTransactionType!
  amount: Int!
  user: EnterpriseUser!
  reason: TransactionReason!
  objectId: Int
  through: String
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  totalCount: Int
}

type TransactionEdge {
  node: Transaction
  cursor: String!
}

enum TransactionReason {
  REFER
  SIGNUP
  CREDIT
}

enum TransactionTransactionType {
  CRD
  DBT
}

type TransformerReview implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  transformerTool: TransformerTool!
  name: String!
  avatar: String!
  comment: String!
}

type TransformerReviewConnection {
  pageInfo: PageInfo!
  edges: [TransformerReviewEdge]!
  totalCount: Int
}

type TransformerReviewEdge {
  node: TransformerReview
  cursor: String!
}

type TransformerRun implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  runId: UUID!
  commitOid: String!
  baseOid: String
  branchName: String
  status: TransformerRunStatus!
  finishedAt: DateTime
  errors: JSONString
  config: JSONString
  pullRequestNumber: Int
  pullRequestStatus: TransformerRunPullRequestStatus!
  committedToBranchStatus: TransformerRunCommittedToBranchStatus!
  createdCommitOid: String
  extraData: JSONString!
  analyzer: Analyzer!
  changedFiles: [String!]!
  tools: GenericScalar
  githubCheckRunId: Int
  githubCheckSuiteId: Int
  changedFilesCount: Int
  changeset: GenericScalar
  finishedIn: Int
  vcsPrUrl: String
  vcsCommitUrl: String
  pullRequestNumberDisplay: String
  commitOidShort: String
  gitCompareDisplay: String
  gitCompareUrl: String
  staleRedirectUrl: String
  errorsRendered: GenericScalar
}

enum TransformerRunCommittedToBranchStatus {
  NCB
  CTB
  CTF
}

type TransformerRunConnection {
  pageInfo: PageInfo!
  edges: [TransformerRunEdge]!
  totalCount: Int
}

type TransformerRunEdge {
  node: TransformerRun
  cursor: String!
}

enum TransformerRunPullRequestStatus {
  PNC
  PRO
  PRC
  PRM
  PRF
}

enum TransformerRunStatus {
  PEND
  PASS
  EMPT
  TIMO
  FAIL
  STAL
}

type TransformerTool implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  analyzer: Analyzer
  documentationUrl: String
  discussUrl: String
  exampleConfig: String
  version: String
  name: String!
  shortcode: String!
  logo: String
  description: String!
  transformerRuns(offset: Int, before: String, after: String, first: Int, last: Int, status: String): TransformerRunConnection!
  reviews(offset: Int, before: String, after: String, first: Int, last: Int): TransformerReviewConnection!
  descriptionRendered: String
  language: String
  publishedOn: Date
  updatedOn: Date
  owner: String
}

type TransformerToolConnection {
  pageInfo: PageInfo!
  edges: [TransformerToolEdge]!
  totalCount: Int
}

type TransformerToolEdge {
  node: TransformerTool
  cursor: String!
}

enum TrendType {
  YEARLY
  MONTHLY
}

input TriggerAdHocRunInput {
  config: String!
  repositoryId: ID!
  clientMutationId: String
}

type TriggerAdHocRunPayload {
  ok: Boolean
  clientMutationId: String
}

input TriggerAnalysisForRepositoryInput {
  repoId: ID!
  clientMutationId: String
}

type TriggerAnalysisForRepositoryPayload {
  ok: Boolean
  clientMutationId: String
}

input TriggerVerifyGSRSSHInput {
  ownerId: ID!
  clientMutationId: String
}

type TriggerVerifyGSRSSHPayload {
  status: String
  clientMutationId: String
}

scalar UUID

input UnsetIssuePriorityInput {
  issueShortcode: String!
  repositoryId: ID
  clientMutationId: String
}

type UnsetIssuePriorityPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateAccessControlSettingsInput {
  teamId: ID!
  syncPermissionsWithVcs: Boolean
  clientMutationId: String
}

type UpdateAccessControlSettingsPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateAccessTokenInput {
  tokenId: ID!
  description: String
  expireInDays: Int
  clientMutationId: String
}

type UpdateAccessTokenPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateBillingInfoInput {
  id: ID
  ownerId: Int
  billingEmail: String
  billingAddress: String
  clientMutationId: String
}

type UpdateBillingInfoPayload {
  billingEmail: String
  billingAddress: String
  clientMutationId: String
}

input UpdateBookmarkedIssueInput {
  repoIssueId: ID!
  action: ActionChoice!
  clientMutationId: String
}

type UpdateBookmarkedIssuePayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateCodeQualitySubscriptionSeatsInput {
  id: ID
  ownerId: Int
  seats: Int!
  clientMutationId: String
}

type UpdateCodeQualitySubscriptionSeatsPayload {
  ok: Boolean
  totalSeats: Int
  clientMutationId: String
}

input UpdateConfigTemplateInput {
  shortcode: String!
  config: JSONString
  title: String
  description: String
  clientMutationId: String
}

type UpdateConfigTemplatePayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateDefaultDashboardContextForUserInput {
  contextOwnerId: Int!
  clientMutationId: String
}

type UpdateDefaultDashboardContextForUserPayload {
  contexts: GenericScalar
  clientMutationId: String
}

input UpdateDefaultPaymentSourceInput {
  id: ID
  ownerId: Int
  token: String
  action: UpdatePaymentActionChoice!
  clientMutationId: String
}

type UpdateDefaultPaymentSourcePayload {
  card: Card
  ok: Boolean
  clientMutationId: String
}

input UpdateEnterpriseInstallationInput {
  name: String
  logo: Attachment
  clientMutationId: String
}

type UpdateEnterpriseInstallationPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateGroupInput {
  groupId: ID!
  name: String!
  clientMutationId: String
}

type UpdateGroupPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateGroupTeamRoleInput {
  groupId: ID!
  teamId: ID!
  role: TeamMemberRoleChoices
  clientMutationId: String
}

type UpdateGroupTeamRolePayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateIssuePriorityInput {
  issueShortcode: String!
  issuePriorityType: ID!
  repositoryId: ID
  clientMutationId: String
}

type UpdateIssuePriorityPayload {
  issue: Issue
  clientMutationId: String
}

input UpdateOrCreateRepositoryCollaboratorInput {
  userId: ID!
  repositoryId: ID!
  permission: RepositoryPermissionChoices
  clientMutationId: String
}

type UpdateOrCreateRepositoryCollaboratorPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateOwnerSettingsInput {
  issueTypeSettings: [IssueTypeSettingInput]!
  ownerId: ID!
  clientMutationId: String
}

type UpdateOwnerSettingsPayload {
  ok: Boolean
  clientMutationId: String
}

enum UpdatePaymentActionChoice {
  UPDATE
  REMOVE
}

input UpdateRepoMetricThresholdInput {
  metricShortcode: String!
  repositoryId: ID!
  thresholdValue: Int
  key: String!
  clientMutationId: String
}

type UpdateRepoMetricThresholdPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateRepositorySettingsInput {
  defaultBranchName: String
  isSubmoduleEnabled: Boolean
  showInDiscover: Boolean
  analyzeChangesetOnly: Boolean
  keepExistingIssues: Boolean
  issueTypeSettings: [IssueTypeSettingInput]
  issuePrioritySettings: [RepositoryIssuePrioritySettingsInput]
  id: ID!
  clientMutationId: String
}

type UpdateRepositorySettingsPayload {
  repository: Repository
  clientMutationId: String
}

input UpdateRepositoryWidgetsInput {
  widgetCodes: [String]!
  repositoryId: ID!
  clientMutationId: String
}

type UpdateRepositoryWidgetsPayload {
  widgetCodes: [String]
  clientMutationId: String
}

input UpdateStarredRepositoryInput {
  repoId: ID!
  action: ActionChoice!
  clientMutationId: String
}

type UpdateStarredRepositoryPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateTeamBasePermissionsInput {
  teamId: ID!
  defaultRepositoryPermission: RepositoryPermissionChoices
  canMembersIgnoreIssues: Boolean
  canMembersModifyMetricThresholds: Boolean
  canContributorsIgnoreIssues: Boolean
  canContributorsModifyMetricThresholds: Boolean
  clientMutationId: String
}

type UpdateTeamBasePermissionsPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateTeamMemberRoleInput {
  ownerId: Int
  ownerPk: ID
  email: String!
  role: TeamMemberRoleChoices!
  clientMutationId: String
}

type UpdateTeamMemberRolePayload {
  role: TeamMemberRoleChoices
  clientMutationId: String
}

input UpdateTechnologyPreferenceInput {
  analyzerShortcodes: [String]
  clientMutationId: String
}

type UpdateTechnologyPreferencePayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateWatchedRepositoryInput {
  repoId: ID!
  action: ActionChoice!
  clientMutationId: String
}

type UpdateWatchedRepositoryPayload {
  ok: Boolean
  clientMutationId: String
}

input UpdateWebhookInput {
  webhookId: ID!
  url: String
  secret: String
  apiSigning: Boolean
  eventsSubscribed: [String]
  clientMutationId: String
}

type UpdateWebhookPayload {
  webhook: Webhook
  clientMutationId: String
}

type User implements MaskPrimaryKeyNode {
  id: ID!
  lastLogin: DateTime
  firstName: String!
  lastName: String!
  isStaff: Boolean!
  isActive: Boolean!
  dateJoined: DateTime!
  scimId: String
  scimExternalId: String
  scimUsername: String
  email: String!
  primaryOwner: Owner
  avatar: String
  preferredTechnologies(offset: Int, before: String, after: String, first: Int, last: Int, categoryIn: [String], q: String): AnalyzerConnection!
  bookmarkedIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection!
  preference: UserPreference
  IsBetaTester: Boolean!
  socialAuth(offset: Int, before: String, after: String, first: Int, last: Int, uid: String, uid_In: [String], provider: String, provider_In: [String]): SocialNodeConnection!
  auditlogSet(offset: Int, before: String, after: String, first: Int, last: Int, actor_In: [String], created: String, createdBefore: String, createdAfter: String, ipAddress_In: [String], eventName_In: [String]): AuditLogConnection!
  primaryOwnerships(offset: Int, before: String, after: String, first: Int, last: Int): OwnerConnection!
  teams(offset: Int, before: String, after: String, first: Int, last: Int, q: String): TeamConnection!
  teamMemberships(offset: Int, before: String, after: String, first: Int, last: Int, q: String, role: [String]): TeamMemberConnection!
  repositorySet(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection!
  transactions(offset: Int, before: String, after: String, first: Int, last: Int, transactionType: String): TransactionConnection!
  scimGroups(offset: Int, before: String, after: String, first: Int, last: Int, q: String): EnterpriseGroupConnection!
  groupusermembershipSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String): GroupUserMembershipConnection!
  autofixrunSet(offset: Int, before: String, after: String, first: Int, last: Int, status: String, status_In: [String], pullRequestStatus_In: [String]): AutofixRunConnection!
  onboardingEvents(offset: Int, before: String, after: String, first: Int, last: Int, owner: ID): AutoOnboardEventConnection!
  repositorycollaboratorSet(offset: Int, before: String, after: String, first: Int, last: Int, q: String, permission: String): RepositoryCollaboratorConnection!
  silenceRulesCreated(offset: Int, before: String, after: String, first: Int, last: Int, creator: ID, issueTitle: String, issueCode: String, filePath: String, silenceLevel: String): SilenceRuleConnection!
  accessTokens(offset: Int, before: String, after: String, first: Int, last: Int): AccessTokenConnection
  fullName: String
  availableCredits: Float
  referralUrl: String
  repositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection
  dashboardContext: GenericScalar
  bookmarkedIssueCount: Int
  recommendedIssues(offset: Int, before: String, after: String, first: Int, last: Int, issueType: String, analyzer: String, sort: String, severity: String, q: String, severityIn: [String], autofixAvailable: Boolean): RepositoryIssueConnection
  gitlabAccounts: [GenericScalar]
  gsrProjects: [GSRProject]
  isAsgardian: Boolean
  intercomUserHash: String
  missiveUserHash: String
  isBetaTester: Boolean
  connectedVcsProviders: [VCSProviderChoices]
}

type UserPreference implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  starredRepositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection!
  watchedRepositories(offset: Int, before: String, after: String, first: Int, last: Int, name_Icontains: String, vcsProvider: String, isPrivate: Boolean, isActivated: Boolean, errorCode: Int): RepositoryConnection!
  user: EnterpriseUser
}

type UserPreferenceConnection {
  pageInfo: PageInfo!
  edges: [UserPreferenceEdge]!
}

type UserPreferenceEdge {
  node: UserPreference
  cursor: String!
}

enum VCSProviderChoices {
  GITHUB
  GITLAB
  BITBUCKET
  GITHUB_ENTERPRISE
  GSR
}

type Verify {
  payload: GenericScalar!
}

input VerifyDeviceInput {
  userCode: String!
  accepted: Boolean!
  clientMutationId: String
}

type VerifyDevicePayload {
  ok: Boolean
  clientMutationId: String
}

input VerifyGSRPermissionsInput {
  ownerId: ID!
  clientMutationId: String
}

type VerifyGSRPermissionsPayload {
  ok: Boolean
  clientMutationId: String
}

input VerifyGSRSetupInput {
  ownerId: ID!
  clientMutationId: String
}

type VerifyGSRSetupPayload {
  ok: Boolean!
  clientMutationId: String
}

input VerifyGSRWebhooksInput {
  ownerId: ID!
  clientMutationId: String
}

type VerifyGSRWebhooksPayload {
  ok: Boolean
  clientMutationId: String
}

type Webhook implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  owner: Owner!
  url: String!
  secret: String!
  apiSigning: Boolean!
  eventsSubscribed(offset: Int, before: String, after: String, first: Int, last: Int): WebhookEventTypesConnection!
  version: String!
  active: DateTime
  deliveries(offset: Int, before: String, after: String, first: Int, last: Int): WebhookEventDeliveryConnection!
}

type WebhookConnection {
  pageInfo: PageInfo!
  edges: [WebhookEdge]!
  totalCount: Int
}

type WebhookEdge {
  node: Webhook
  cursor: String!
}

type WebhookEventDelivery implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  deliveryId: String
  eventId: String
  httpStatusCode: Int
  retryCount: Int
  webhook: Webhook!
  eventType: WebhookEventTypes!
  payload: GenericScalar
  finishedIn: Float
}

type WebhookEventDeliveryConnection {
  pageInfo: PageInfo!
  edges: [WebhookEventDeliveryEdge]!
  totalCount: Int
}

type WebhookEventDeliveryEdge {
  node: WebhookEventDelivery
  cursor: String!
}

type WebhookEventTypes implements MaskPrimaryKeyNode {
  id: ID!
  createdAt: DateTime!
  modifiedAt: DateTime!
  alive: Boolean
  name: String!
  shortcode: String!
  shortDescription: String!
  isPrivate: Boolean!
  webhooks(offset: Int, before: String, after: String, first: Int, last: Int): WebhookConnection!
  deliveries(offset: Int, before: String, after: String, first: Int, last: Int): WebhookEventDeliveryConnection!
}

type WebhookEventTypesConnection {
  pageInfo: PageInfo!
  edges: [WebhookEventTypesEdge]!
  totalCount: Int
}

type WebhookEventTypesEdge {
  node: WebhookEventTypes
  cursor: String!
}

input WebhookSecretInput {
  clientMutationId: String
}

type WebhookSecretPayload {
  secret: String
  clientMutationId: String
}
