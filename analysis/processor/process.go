package processor

import (
	"github.com/deepsourcelabs/cli/types"
)

// Processor interface to receive analysis post-processors.
type IProcessor interface {
	String() string
	Process([]string, *types.Issue, *[]types.Issue) error
}

// ReportProcessor struct contains the processor data needed to process the analysis results.
type ReportProcessor struct {
	CodePath   string               // The source code path where the issues got raised.
	Processors []IProcessor         // The list of supported post-analysis processors.
	Report     types.AnalyzerReport // The report generated by the Analyzer post analysis.
}

// ProcessAnalyzerReport accepts the result as a byte array and processes the results in the form of a
// AnalyzerReport struct instance.
// It sorts the issues in an alphabetical order of filenames just to ensure that all issues getting
// reported for the same files come together & processes the issues for the various required processors.
// As of now, there are two processors supported:
// - skipcq : Processes the issues and checks if some of them should be ignored since they have
//            been ignored by the user through suitable `skipcq` comments.
// - source_code_load :  Processes the issues for the source code snippets, highlights the snippets
//                       and adds them to the Analysis result.
func (p *ReportProcessor) Process() types.AnalysisResult {
	// Covert the Analyzer report from LSP based format to the default results format.
	analysisResult := p.formatLSPResultsToDefault()

	// Check if there are issues reported actually.
	if len(analysisResult.Issues) <= 0 {
		return analysisResult
	}

	// All the files that appear in the issues are now processed by the processors listed in analyzer conf
	// We must cache the files in order to not do file IO for every processor.
	p.sortIssuesByFile(&analysisResult)

	// Get the issues to file range data.
	filesIndex := createIssueFileRange(analysisResult)

	// Iterate over the filesIndex and read the files in batch and process the issues using the suitable processors.
	processedIssues := []types.Issue{}
	p.processIssuesBatch(filesIndex, &analysisResult, &processedIssues)
	analysisResult.Issues = processedIssues

	// Sort again for consistency (mostly for test to pass).
	p.sortIssuesByFile(&analysisResult)

	// Return the processed analysis result.
	return analysisResult
}
