package processor

import (
	"fmt"

	"github.com/deepsourcelabs/cli/types"
)

type fileContentNode struct {
	Filename    string
	FileContent []string
}

// Processor interface to receive analysis post-processors.
type IProcessor interface {
	Process([]string, *types.Issue, *[]types.Issue) error
}

// ProcessAnalysisResults struct contains the data needed to process the analysis results.
type ProcessAnalysisResults struct {
	CodePath        string               // The source code path where the issues got raised.
	Processors      []IProcessor         // The list of supported post-analysis processors.
	ProcessedIssues []types.Issue        // List of issues post-processing.
	Report          types.AnalyzerReport // The report generated by the Analyzer post analysis.
	AnalysisResult  types.AnalysisResult // The final result published post processing the Analyzer report.
}

// Accepts the result as a byte array and processes the results in the form of a
// AnalyzerReport struct instance.
func (p *ProcessAnalysisResults) ProcessAnalysisResult() {
	// Covert the Analyzer report from LSP based format to the default results format.
	p.formatLSPResultsToDefault()
	fmt.Println("Total issues reported by the Analyzer: ", len(p.AnalysisResult.Issues))

	// Check if there are issues reported actually.
	if len(p.AnalysisResult.Issues) <= 0 {
		return
	}

	// Once the result has been converted to the DeepSource format, start processing the issues.
	p.processIssues()
}

// processIssues sorts the issues in an alphabetical order of filenames just to ensure that all issues getting
// reported for the same files come together & processes the issues for the various required processors.
// As of now, there are two processors supported:
// - skipcq : Processes the issues and checks if some of them should be ignored since they have
//            been ignored by the user through suitable `skipcq` comments.
// - source_code_load :  Processes the issues for the source code snippets, highlights the snippets
//                       and adds them to the Analysis result.
func (p *ProcessAnalysisResults) processIssues() {
	// All the files that appear in the issues are now processed by the processors listed in analyzer conf
	// We must cache the files in order to not do file IO for every processor.
	p.sortIssuesByFile()

	// Get the issues to file range.
	filesIndex := createIssueFileRange(p.AnalysisResult)

	// Iterate over the filesIndex and read the files and process the issues using the suitable processors.
	p.processIssuesBatch(filesIndex)
	p.AnalysisResult.Issues = p.ProcessedIssues

	// Sort again for consistency (mostly for test to pass).
	p.sortIssuesByFile()
}
